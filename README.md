# 军旗游戏 (Chinese Military Chess Game)

一个基于Qt框架开发的经典军旗游戏，支持玩家对战和AI对战模式，实现了完整的游戏逻辑和智能AI算法。

![image]()

## 📋 目录

- [游戏简介](#游戏简介)
- [功能特性](#功能特性)
- [技术栈](#技术栈)
- [游戏规则](#游戏规则)
- [AI算法](#ai算法)
- [项目结构](#项目结构)
- [快速开始](#快速开始)
- [游戏截图](#游戏截图)
- [开发说明](#开发说明)

## 🎮 游戏简介

军旗是一种经典的中国策略棋类游戏，两名玩家各自控制一支军队，通过策略性的移动和战斗，目标是占领对方的军旗或消灭对方所有可移动棋子。

本项目使用C++和Qt框架实现，提供了直观的图形界面和智能的AI对手，支持多种游戏模式。

> 💡 **快速体验**: 可直接从右侧 [Releases](https://github.com/lihuayao945/Military-chess/releases/download/game/Military.Chess.zip) 下载可执行文件，无需安装任何依赖！

## ✨ 功能特性

### 🎯 游戏模式
- **玩家对战模式**: 两名玩家轮流操作
- **简单AI模式**: 基于BFS算法的AI对手
- **困难AI模式**: 基于A*算法的高级AI对手

### 🎲 游戏特性
- 完整的军旗游戏规则实现
- 随机棋子布局生成
- 实时游戏状态显示
- 直观的点击操作界面
- 胜负判定系统

### 🤖 AI特性
- 多层次难度设计
- 智能路径规划
- 威胁评估系统
- 战术决策算法

## 🛠 技术栈

### 核心技术
- **编程语言**: C++
- **GUI框架**: Qt 5.x
- **构建系统**: qmake
- **设计模式**: MVC架构

### 算法实现
- **BFS广度优先搜索**: 简单AI路径规划
- **A*启发式搜索**: 困难AI智能决策
- **曼哈顿距离**: 启发式函数
- **状态空间搜索**: 游戏状态评估

## 📖 游戏规则

### 棋盘布局
- **棋盘大小**: 12×5网格
- **阵营分布**: 上下两个阵营，各占6行
- **特殊区域**: 
  - 军旗位置：上方(0,3)，下方(11,1)
  - 地雷位置：上方(0,2)和(0,4)，下方(11,0)和(11,2)
  - 行营：安全区域，可斜向移动

### 棋子等级
| 等级 | 名称 | 数量 | 特殊能力 |
|------|------|------|----------|
| 9 | 司令 | 1 | 最高等级兵种 |
| 8 | 军长 | 1 | 高级军官 |
| 7 | 师长 | 2 | 中级军官 |
| 6 | 旅长 | 2 | 中级军官 |
| 5 | 团长 | 2 | 中级军官 |
| 4 | 营长 | 2 | 中级军官 |
| 3 | 连长 | 3 | 基础军官 |
| 2 | 排长 | 3 | 基础军官 |
| 1 | 工兵 | 3 | 可挖地雷 |
| 10 | 炸弹 | 2 | 同归于尽 |
| 11 | 地雷 | 2 | 固定防御 |
| 12 | 军旗 | 1 | 胜利目标 |

### 移动规则
1. **基本移动**: 相邻格子移动（上下左右）
2. **行营移动**: 在行营内可斜向移动
3. **铁路移动**: 特定行列可多格跳跃
4. **战斗规则**: 高等级吃低等级，同等级同归于尽
5. **特殊规则**: 
   - 工兵可挖地雷
   - 炸弹与任何棋子同归于尽
   - 军旗和地雷不能移动

### 胜利条件
- 占领对方军旗
- 消灭对方所有可移动棋子

## 🧠 AI算法

### 简单AI (EasyAI)
基于**BFS广度优先搜索**算法实现：

```cpp
void EasyAI::bfsToTarget(int startX, int startY, int targetX, int targetY, 
                        int nowBoard[12][5], int& stepNum, int step[4])
```

**策略特点**:
- 寻找到军旗的最短路径
- 识别敌方高价值目标
- 简单的威胁评估
- 基础的战术选择

### 困难AI (DifficultAI)
基于**A*启发式搜索**算法实现：

```cpp
void DifficultAI::aStarToTarget(int startX, int startY, int targetX, int targetY,
                               int nowBoard[12][5], int& stepNum, int step[4])
```

**高级特性**:
- **启发式函数**: 使用曼哈顿距离优化搜索
- **威胁分层**: 区分5步内外的威胁等级
- **安全评估**: `willBeEatOneStep()`函数评估移动风险
- **战术多样性**: 
  - 炸弹行营战术
  - 防御性移动
  - 进攻优先级判断

**核心算法流程**:
1. 状态评估：分析当前棋盘局势
2. 目标识别：确定高价值敌方目标
3. 路径规划：使用A*算法计算最优路径
4. 风险评估：评估移动的安全性
5. 决策执行：选择最优策略执行

## 📁 项目结构

```
junqi/
├── Logical/                 # 核心逻辑代码
│   ├── main.cpp            # 程序入口
│   ├── Game.h/cpp          # 游戏主控制类
│   ├── Board.h/cpp         # 棋盘逻辑
│   ├── Piece.h/cpp         # 棋子类
│   ├── AI.h                # AI基类
│   ├── EasyAI.h/cpp        # 简单AI实现
│   ├── DifficultAI.h/cpp   # 困难AI实现
│   ├── ChessPieceOp.h/cpp  # 棋子操作类
│   ├── form.h/cpp          # 主菜单界面
│   ├── mainwindow.h/cpp    # 游戏主界面
│   ├── *.ui                # Qt界面文件
│   ├── resource.qrc        # 资源文件
│   └── *.png               # 棋子图片资源
└── Qt-Logical/             # 编译输出目录
    └── untitled1.exe       # 可执行文件
```

### 核心类说明

#### Game类
- 游戏主控制器
- 管理游戏流程和状态
- 协调玩家操作和AI决策

#### Board类
- 棋盘状态管理
- 移动合法性验证
- 战斗结果计算

#### AI类层次
```
AI (抽象基类)
├── EasyAI (BFS算法)
└── DifficultAI (A*算法)
```

## 🚀 快速开始

### 直接运行 (推荐)
1. 前往右侧 **[Releases](../../releases)** 页面
2. 下载最新版本的可执行文件
3. 双击运行即可开始游戏

### 从源码编译
如果您想从源码编译或进行开发：

**环境要求**:
- Qt 5.x 或更高版本
- C++11 或更高标准

**编译步骤**:
1. 克隆项目: `git clone [repository-url]`
2. 使用Qt Creator打开 `Logical/untitled1.pro`
3. 点击"构建"并运行

## 📸 游戏截图

### 主菜单界面
游戏启动后显示的主菜单，提供三种游戏模式选择：
- 玩家对战
- 简单人机
- 困难人机

### 游戏界面
- 12×5的军旗棋盘
- 上下两个阵营的棋子布局
- 实时状态显示
- 点击操作提示

### AI对战演示
展示AI的智能决策过程和战术选择。

## 🔍 算法详解

### BFS算法实现 (简单AI)
```cpp
// 核心BFS搜索逻辑
std::queue<std::pair<int, int>> q;
bool visited[12][5];
int distance[12][5];

// 八方向搜索
int directions[8][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1},
                        {-1, -1}, {-1, 1}, {1, -1}, {1, 1}};
```

**算法特点**:
- 时间复杂度: O(V + E)，其中V是节点数，E是边数
- 空间复杂度: O(V)
- 保证找到最短路径
- 适合简单的路径规划

### A*算法实现 (困难AI)
```cpp
// A*核心数据结构
struct Node {
    int x, y;           // 坐标
    int g, h, f;        // g:实际代价, h:启发式代价, f:总代价
    std::pair<int, int> parent; // 父节点
};

// 启发式函数：曼哈顿距离
auto heuristic = [&](int x, int y) {
    return std::abs(x - targetX) + std::abs(y - targetY);
};
```

**算法优势**:
- 时间复杂度: O(b^d)，其中b是分支因子，d是解的深度
- 启发式函数指导搜索方向
- 在保证最优解的前提下提高搜索效率
- 适合复杂的战术决策

### 威胁评估算法
```cpp
bool DifficultAI::willBeEatOneStep(int x, int y, int nowBoard[12][5], int currentLevel) {
    // 检查周围8个方向是否有敌方棋子能够攻击
    // 评估移动到该位置的安全性
}
```

**评估维度**:
1. **距离威胁**: 5步内外的威胁分级
2. **等级威胁**: 敌方棋子等级评估
3. **位置威胁**: 特殊位置（行营、铁路）的安全性
4. **战术威胁**: 炸弹、地雷等特殊棋子的威胁

## 🎯 开发说明

### 代码架构
项目采用经典的MVC架构模式：
- **Model**: Game, Board, Piece类负责业务逻辑
- **View**: Qt UI界面负责显示
- **Controller**: MainWindow, ChessPieceOp类处理交互

### 扩展开发
1. **添加新AI算法**: 继承AI基类，实现getNextStep方法
2. **界面美化**: 修改UI文件和资源文件
3. **规则扩展**: 在Board类中添加新的移动规则
4. **网络对战**: 可扩展支持网络多人游戏

### 性能优化
- A*算法使用优先队列优化搜索效率
- 棋盘状态使用数组存储，访问效率高
- UI更新采用增量刷新机制

## 🤝 贡献

欢迎提交Issue和Pull Request来改进这个项目！

## 📄 许可证

本项目采用MIT许可证，详见LICENSE文件。

---

**享受游戏！** 🎮✨
